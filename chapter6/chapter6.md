### Terms

* replica: refer to the node that stores one copy of the db is called a replica.

* replication:a technology that keeping a copy of the same data on multiple machines that are connected via network.

* partition: when dataset becomes huge or query frequency becomes high, dataset will break up into smaller fractions which called partitions; 

* hot spot: A partition with disproportionately high load.

* rebalancing: the process of movin load from one node to another in cluster is called rebalancing.


### Chapter6 Strucures
* ![c6_mindmapping](https://github.com/nanachi1027/DDIA-Notes/blob/master/chapter6/c6.png)


### Questions
#### Key & Value Dataset partitioning strategies 
* What's the different and relationship between replication and partition?
> Diff
```
replication:
1. replication is multiple copies of the same data on different nodes;
2. replication aim to resolve fault tolerance or redundancy in distributed system;

partition:
1. when node's replicated data size and request frequency becomes huge, replicated data gonna broken up into smaller fractions;
2. partition aims to improve data scalability reduce hot spot and improve parallel resource usage:
   the more data partitioned more complex query will be brokern in,
   the more queries will be send to different partitions and parallel executing;
```

> Relation
```
partition is usually combined with repication, copies of each partition are stored on multiple nodes,
and each record belongs to exactly partition, it may still be stored on different nodes for fault tolerance;
```

* What's the goal of partition?
```
1. For data's scalability t reduce hot spots in which multiple requests are sent to single node and this node's load gonna be high;
2. Large datasets can be distributed across many disks, cpus, more partitions you break up your dataset into, more query load can be distributed across multiple processors;
```
* What's the simplest way to avoid hot spot?
```
> The simplest way to reduce(avoid) hot spot is assigning records to nodes randomally.
> But, this has a disadvantage that is : when you trying to read a paticular item, a global partitions scanning will be executed.
```


##### Partitioning by key range
* What's key range partition, what's th pros and cons of this key range based partition approach?
```
1. One way of partitioning data is to assign a continues range of way to each partition.
In that way, the range of keys are binded to the partition and suppose if we know the boundaries of each range, we can easily know which partition contains the given key.
Partitioning key by range or also be called the key-range based partitioning strategy is used in BigTable which opensource equivalent the HBase, RethinkDB and MongoDB. 

2. Pros of this key-range based partitioning strategy is it supports records sort by key inside one partition which makes range scan more effective. 

3. Cons of this partitioning is some certain access partten can also lead to hot spots. For instance: 
If the key is a timestamp, then the partitions correspond to ranges of time -- all data in one day is stored inside one partition, all write request will be sent to one partition which can be overloaded with writes becomes hot spot and others sit idle. 
```
##### Partitioning by hash of key range 
* What's hash key partitioning strategy and what's pros and cons of this strategy?
```
Unlike key-range based partitioning strategy that assign each partition a range of key, in hash-key based partitioning strategy a range of hashes are assigned to partitions. 
And each key whose hash value which generated by specified hash function falls with-in a partitions range will be stored in that partition. 

Pros of this partitioning strategy is hash of key is a good technique to distribute keys fairly among the partitions. 

Cons of this partitioning strategy is the hash of the key for partitioning will lead to lose range queries which means all data records (key, value) are organized/indexed by hash value instead of key. 
So sort by key to make records in order becomes impossible. 
```

#### Secondary index approaches
* What's secondary index? How many secondary index types? 
```
> Different from primary index that usually built to identify an uniquely record from global dataset; the secondary is usually built to provide an efficient way to search for occurrences of a particular value, like:
find all articles containing the specified word 'hogwash', find all cars whose color is red.

> There are two main approaches to partitioning a database with secondary indexes: 
>> document-based partitioning; 
>> term-based partitioning; 
```

* Which system use secondary? which not and why?
```
Secondary index is the butter and bread to RMDB.

Riak is the key-value database which support secondary index because they are so useful in data modeling.  

Whereas, HBase and Voldemort have avoided secondary index in case of implementation complexity.
```

* What's document-based partitioning, what's Pros and Cons when build secondary index adopt it? 
```
In document-based partitioning each partition and its partition index are completely separate; The secondary indexes in each partition only covery that partition's document. 
Data records modifying: delete, add, updatation won't effect its secondary index. For this reason, the document-partitioned index is also known as a local-index. 

Pros of document-based index:
Pros of this secondary index is you don't care about data modification in other partition, in each read/write request we only care about the partitons which contains the related document-id.


Cons of document-based index:
Cons of this secondary index appraoch is that, it is local index, in every reading queries on secondary indexes we have to scan whole partitoins to find which partitions contains the related document-id cause we do not have a global view of the index-partition maping ; 

Then executee query per realted partitions which contain the related document-id and combined the query results from each partition into one result. 

The approach to querying a partitioned database which we described above is sometimes known as scatter/getter, which make read queries on secondary indexes quite expensive. Even if your quires is execute in parallel. Usually result in tail latency which caused by some partitions response slow than the others. 
```

* what's term-based partitioning, What's Pros and Cons when build secondry index adopt this indexing approach?
```
Different from each partition maintains its local index(document-based index), term-based index is the global index in which covers data from all partitions.

Term-based secondary indexes won't store in one node in case of bottleneck, global index also need partitioned to different nodes. 

Pros of term-based secondary index is we can partition the index by the term itself, of using a hash of the term, the former one can be useful when execute a range scan, and the later one can be useful to distribute query load. 

Term-based secondary index can let read query execute more effectively than doc-based secondary index, cause the former one knows which partitions it need to query instead of global scanning each partitions. 


Cons of term-based secondary index is writing/inserting/updating data:
cause global index needs to udpating according to the new data inserting or old data updating which make wring data slower and more complex.

A single column's writing will affect multiple partitions and its secondary indexes. 


In an ideal world, the index would always be up to date, and every document write to the database, the index of the dataset would be updated immediately.

However, in practice, updates to the global secondary index are often asynchronous (that is, if you read the index shortly after a write, the change you just made may not yet be relfected in the index).

```

* Document-based secondary index vs. Term-based secondary index?
```
index maintenance
> doc-based index's maintenance is more easily, it is local index, updatation upoin index only happen inside current partition;
> term-based index's maintenance is difficult, it is global index, 
one record inseration will relfect to multiple partitions,
also indexes are also partioned distributely which make write & udpate more slow and complex; 

read speed
> doc-based index: read query will lead to scatter/gatter and read query's result is combined from multiple partitions in which contains corresponding query doc-id; 
> term-based index: read query is more effective than doc-based, cause 
a global index is maintained, query client know which partitions contain the specified doc-id and send request to the partitions in stead of scan overall partitions. 

write speed
> doc-based index: more simple and effecitve, only cares about its local partition's data updation.
> term-based index: more complex and slow, simple data updation affects multiple or even global indices.

k-v db adoption
> doc-based: MongoDB, Riak, Cassandra, ES, SolrCloud, VoltDB; 
> term-based: Amazon DynamoDB, Riak, Oracle data warehouse; 
```

#### Rebalancing partitions approache 
* What's rebalancing partitions? Why we need rebalancing partitions(adopt to solve what kind of problems)? 
```
When following things happen:
> query load increases, more processors and memorys are needed in current node -- we need to distributed computing pressure among nodes;  
> datasize increases -- we need to distribute storage pressure among nodes; 
> machine which deployed 1 or more system's services down -- we need to migrate service(s) to other nodes; 

All these scenarios above needs the system move data from one node to other nodes in the system.
The process of moving load from one node to another in the cluster(system) is called rebalancing; 
```

* What's the minimum requirements in a rebalancing process? 
```
> After rebalancing, the load (data storage, read and write requests) should be shared fairly between the nodes in the cluster; 
> Database(cluster/system)'s services shouldn't be affected during rebalancing period; 
> Data migration among nodes during rebalancing should be kept as small as possible in case of casuing huge I/o load among netowkr and disks;
```

##### Strategies

* How many strategies can be used in rebalancing ?
```
* Hash mod N
* Fixed number of partitions
* Dynamic partitioning
* Paritioning proportionally to nodes
```

##### Hash mod N 
* Can you explain how hash mod N rebalancing strategies works in the system?
```

```

* Why we just directly use key mod N which the key is the key of (k, v) record and the N means the total number of Nodes in the cluster? 
```
```

##### Fixed number partition
* Do you konw in fixed number of partitions rebalancing strategy how partitions and nodes are organized in the system?
```
```

* What happens if a node adds to / removes from a cluster if this cluster adopt fixed partition rebalancing strategy?
```
```

* What are the pros and cons to use fixed partition rebalancing ?
```
```

* How fixed partition relbancing strategy deal with the situaiton in which the size of the whole dataset expands too huge or shrinks too small?
```
```


##### Dynamic partition 
* Can you explain more details about the dynamic partition rebalancing strategy?
```
```

* What happens when a node is added/removed from a cluster which uses the dynamic partition rebalancing strategy?
```

```

* How does dynamic partition strategy handle the situation in which: size of the dataset becomes too huge or shrink too small ?
```
```

* What are the pros and cons when adopt this rebalancing strategy?
```
```

##### Partitioning propotionally to nodes
* Can you tell more details about this rebalancing strategy?
```
```

* How cluster which adopt this rebalancing strategy organizes the assocation between partition and nodes ?
```
```

* Explain how this rebalancing strategies working when cluster's dataset expands too huge or shrinks too small?
```
```


##### Operations 
* What's the pros and cons of auto rebalancing and rebalancing in manual?
```
```

##### Routing Request 

